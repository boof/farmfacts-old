## Deprecation in Sequel 1.5

During its development, Sequel has accumulated some cruft. In addition, it supported and encouraged too much magic, some of which can make bugs harder to track down. Therefore, we are deprecating the following methods from Sequel 1.5, and *they will be removed in Sequel 2.0*.

### `Sequel.method_missing`

`Sequel.method_missing` was used to implement the adapter methods, such as `Sequel.postgres`. Those adapter methods are now created via metaprogramming, so there should be no need for `Sequel.method_missing` (unless you wrote your own database adapter, in which case you should add a method for it).

### `Sequel::Dataset#method_missing`

`Sequel::Dataset#method_missing` was used for two things:

- Mutation methods, such as `filter!`, which modified the receiver
- Magic methods, such as `find_by_name`

Mutation methods are now defined via metaprogramming for most methods for which they would make sense. If you are using a mutation method that isn't defined and you think it should be, post on the Google Group and let us know.

Magic methods are a bad idea in general. If you need to use a magic method, define it yourself, or use the simple alternative. Here are the deprecated magic methods and their alternatives:

* `order_by_XXX       => order(:XXX)`
* `first_by_XXX       => order(:XXX).first`
* `last_by_XXX        => order(:XXX).last`
* `filter_by_XXX(YYY) => filter(:XXX => YYY)`
* `all_by_XXX(YYY)    => filter(:XXX => YYY).all`
* `find_by_XXX(YYY)   => filter(:XXX => YYY).first`
* `group_by_XXX       => group(:XXX)`
* `count_by_XXX       => group_and_count(:XXX)`

### `Sequel::Dataset#clone_merge`

This is an alias for clone, and was marked that it should be deprecated in the next version in the source.

### `Sequel::Dataset#set_options`

This should have been a private method (Sequel didn't use private methods at all until recently), and I doubt much uses it. It was called internally by clone.

### `Sequel::Dataset#set_row_proc`

This was used to redefine methods such as each, but now it just sets the `@row_proc` variable. Since Dataset now has an `attr_accessor` for the `@row_proc`, this is necessary. Use `row_proc=`.

### `Sequel::Dataset#remove_row_proc`

Similar to `set_row_proc`. Use `row_proc = nil` instead.

### `Object.include(ColumnMethods)`

This was a poor design decision that added 9 methods to every object (`as`, `AS`, `desc`, `DESC`, `asc`, `ASC`, `all`, `ALL`, and `cast_as`). It made some bugs much harder to track down (especially `all`, since that is a common method name). `ColumnMethods` is now only 4 methods (`as`, `desc`, `asc`, and `cast_as`), and it is included in `Symbol`, `String`, and `Sequel::SQL::Expression`. In addition `Symbol#*` was added, so you can do `:table_name.*`. For strings, there isn't a direct `.all` replacement, so use `'table_name.*'.lit`.

### `Object#Sequel`

This was a convenience method to Sequel.connect. However, it adds a Sequel method to every object, for a small gain of 8 characters for code that is only used once.

### `Object#rollback!`

This was a convenience method that raised `Sequel::Error::Rollback`. It allowed easy rolling back inside a database transaction. However, it adds a method to every object, just for a saving of 20 characters.

### `Symbol#method_missing`

This was another poor design decision that allowed any uppercase method method name to be used against any symbol in order to define an SQL function. Since `Symbol#[]` exists and reflects the intent better (looking like a function call), you should use that:

* `:number.SUM => :sum[:number]`
* `:price.MIN  => :min[:price]`

### `Model.method_missing`

This was used so that you could call dataset methods directly on the model. Most of the dataset methods you would want to call have been added via metaprogramming. If you want to define a method on the dataset with a model method to access it directly, use `Model.def_dataset_method`.

### `Model#method_missing`

This was used to provide attribute accessors for each column in the dataset. Now the dataset methods are defined when the class inside `set_dataset`, which is now usually called when the model class is created. One situation where `method_missing` could still be used is if you aliased columns and then used and accessor to get through them:

* `Model.select(:name___aliased_name).first.aliased_name => Model.select(:name___aliased_name).first[:aliased_name]`
* `Model.select('title AS subject'.lit).first.subject = 'New Title' => Model.select('title AS subject'.lit).first[:subject] = 'New Title'`

### `Model.create_with_params, Model.create_with`

After some refactoring, these are both the same as `Model.create`.

### `Model#update_with`

This is an alias to `Model#update_with_params`, but it is harder to read (update with what?).

### `Model#new_record?`

This is an alias to `Model#new?`, which is more concise and just as expressive.

### `Model#set`, `Model#update`

These are currently aliases to `Model#update_values`. Both are low level methods that don't use callbacks and should probably be avoided. Also confusing is that set does modify the database, which violates the principal of least surprise. `Model#set` and `Model#update` mirror the dataset methods of the same names, but models and datasets have different semantics, so it's a broken metaphor.

### `Model.one_to_one`

This was a left over from the pre-1.3 association code, and was already deprecated in its own way starting in 1.3. It's also a broken metaphor, as the association isn't `one_to_one`, it's `many_to_one` (many of the current object to one of the associated object) Use `many_to_one` instead.

#### `Model.association :from` option

This was also deprecated in its own way starting in 1.3. Use the `:class` option.
